name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  # ==================== BUILD & TEST ====================
  build:
    name: Build & Test
    runs-on: self-hosted

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Setup Environment Variables for Build Test
        run: |
          echo "ğŸ” Setting up environment variables for build test..."
          
          # Create .env file using GitHub Secrets
          cat > .env << EOF
          # Database Configuration from GitHub Secrets
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

          # Backend Configuration
          NODE_ENV=production
          PORT=3000
          DATABASE_HOST=postgres
          DATABASE_PORT=5432
          DATABASE_NAME=${{ secrets.POSTGRES_DB }}
          DATABASE_USER=${{ secrets.POSTGRES_USER }}
          DATABASE_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          API_BASE_URL=${{ secrets.API_BASE_URL }}
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
          API_PORT=3000
          API_HOST=0.0.0.0

          # Frontend Configuration
          NUXT_PUBLIC_API_BASE=${{ secrets.NUXT_PUBLIC_API_BASE }}
          NUXT_PUBLIC_FRONTEND_URL=${{ secrets.NUXT_PUBLIC_FRONTEND_URL }}
          NUXT_PUBLIC_APP_NAME=${{ secrets.NUXT_PUBLIC_APP_NAME }}
          NUXT_PUBLIC_MEDIA_BASE=${{ secrets.NUXT_PUBLIC_MEDIA_BASE }}
          EOF

      - name: ğŸ§¹ Clean Docker Cache
        run: |
          echo "ğŸ§¹ Cleaning Docker cache before build test..."
          docker system prune -f || true
          docker builder prune -f || true

      - name: ğŸ—ï¸ Test Build Backend
        run: |
          docker compose -f docker compose.production.yml build --no-cache backend

      - name: ğŸ—ï¸ Test Build Frontend
        run: |
          docker compose -f docker compose.production.yml build --no-cache frontend

      - name: ğŸ”§ Fix ownership after Docker builds
        run: |
          sudo chown -R ${{ env.USER_ID }}:${{ env.GROUP_ID }} ${{ github.workspace }} || true
          sudo chmod -R 755 ${{ github.workspace }} || true

      - name: âœ… Build Test Completed
        run: echo "Build test completed successfully!"

  # ==================== DEPLOY ====================
  deploy:
    name: Deploy to Production
    runs-on: self-hosted
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Setup Environment Variables from GitHub Secrets
        run: |
          echo "ğŸ” Setting up environment variables from GitHub secrets..."

          # Create .env file from GitHub secrets
          cat > .env << EOF
          # Database Configuration from GitHub Secrets
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

          # Backend Configuration
          NODE_ENV=production
          PORT=3000
          DATABASE_HOST=postgres
          DATABASE_PORT=5432
          DATABASE_NAME=${{ secrets.POSTGRES_DB }}
          DATABASE_USER=${{ secrets.POSTGRES_USER }}
          DATABASE_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          API_BASE_URL=${{ secrets.API_BASE_URL }}
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
          API_PORT=${{ secrets.API_PORT }}
          API_HOST=${{ secrets.API_HOST }}

          # Frontend Configuration
          NUXT_PUBLIC_API_BASE=${{ secrets.NUXT_PUBLIC_API_BASE }}
          NUXT_PUBLIC_FRONTEND_URL=${{ secrets.NUXT_PUBLIC_FRONTEND_URL }}
          NUXT_PUBLIC_APP_NAME=${{ secrets.NUXT_PUBLIC_APP_NAME }}
          NUXT_PUBLIC_MEDIA_BASE=${{ secrets.NUXT_PUBLIC_MEDIA_BASE }}
          EOF

      - name: ğŸš€ Zero Downtime Deploy to Production
        run: |
          echo "ğŸ“¥ Code already checked out..."

          # Create backup directory
          echo "ğŸ’¾ Creating backup directory..."
          mkdir -p /home/hieunq/roommate_backups
          timestamp=$(date +'%Y%m%d_%H%M%S')
          backup_path="/home/hieunq/roommate_backups/backup_$timestamp"
          mkdir -p "$backup_path"

          # Backup current deployment
          echo "ğŸ’¾ Backing up current deployment..."
          cp docker compose.production.yml "$backup_path/" || true
          cp .env "$backup_path/" || true
          cp ./.docker/production/nginx/nginx.conf "$backup_path/" || true
          docker compose -f docker compose.production.yml images > "$backup_path/images.txt" || true

          # Pre-deployment health check
          echo "ğŸ¥ Pre-deployment health check..."
          if docker compose -f docker compose.production.yml ps | grep -q "Up"; then
            echo "ğŸ“Š Current services status:"
            docker compose -f docker compose.production.yml ps
          fi

          # Clean up old images and cache before building
          echo "ğŸ§¹ Cleaning up old images and cache..."
          docker system prune -f || true
          docker builder prune -f || true
          
          # Build new images without cache (fresh build)
          echo "ğŸ”¨ Building new images without cache..."
          docker compose -f docker compose.production.yml build --no-cache --parallel

          # Zero downtime rolling update
          echo "ğŸ”„ Starting zero downtime rolling update..."

          # Update postgres first (if needed)
          echo "ğŸ“Š Updating postgres..."
          docker compose -f docker compose.production.yml up -d --no-deps postgres
          sleep 10

          # Update backend with health check
          echo "ğŸ”§ Updating backend..."
          docker compose -f docker compose.production.yml up -d --no-deps backend
          
          # Wait for backend to be healthy
          echo "ğŸ¥ Waiting for backend to be healthy..."
          backend_healthy=false
          for i in {1..30}; do
            if docker compose -f docker compose.production.yml ps backend | grep -q "healthy"; then
              echo "âœ… Backend is healthy"
              backend_healthy=true
              break
            fi
            echo "Attempt $i/30: Backend not ready yet..."
            sleep 10
          done
          
          if [ "$backend_healthy" = false ]; then
            echo "âŒ Backend failed to become healthy"
            echo "ğŸ”„ Rolling back..."
            cp "$backup_path/docker compose.production.yml" ./ || true
            cp "$backup_path/.env" ./ || true
            docker compose -f docker compose.production.yml up -d
            exit 1
          fi

          # Update frontend
          echo "ğŸ¨ Updating frontend..."
          docker compose -f docker compose.production.yml up -d --no-deps frontend
          
          # Wait for frontend to be healthy
          echo "ğŸ¥ Waiting for frontend to be healthy..."
          frontend_healthy=false
          for i in {1..20}; do
            if docker compose -f docker compose.production.yml ps frontend | grep -q "healthy"; then
              echo "âœ… Frontend is healthy"
              frontend_healthy=true
              break
            fi
            echo "Attempt $i/20: Frontend not ready yet..."
            sleep 5
          done
          
          if [ "$frontend_healthy" = false ]; then
            echo "âŒ Frontend failed to become healthy"
            echo "ğŸ”„ Rolling back..."
            cp "$backup_path/docker compose.production.yml" ./ || true
            cp "$backup_path/.env" ./ || true
            docker compose -f docker compose.production.yml up -d
            exit 1
          fi

          # Update nginx last (entry point)
          echo "ğŸŒ Updating nginx..."
          docker compose -f docker compose.production.yml up -d --no-deps nginx
          
          # Wait for nginx to be healthy
          echo "ğŸ¥ Waiting for nginx to be healthy..."
          nginx_healthy=false
          for i in {1..20}; do
            if docker compose -f docker compose.production.yml ps nginx | grep -q "healthy"; then
              echo "âœ… Nginx is healthy"
              nginx_healthy=true
              break
            fi
            echo "Attempt $i/20: Nginx not ready yet..."
            sleep 5
          done
          
          if [ "$nginx_healthy" = false ]; then
            echo "âŒ Nginx failed to become healthy"
            echo "ğŸ”„ Rolling back..."
            cp "$backup_path/docker compose.production.yml" ./ || true
            cp "$backup_path/.env" ./ || true
            docker compose -f docker compose.production.yml up -d
            exit 1
          fi

          # Fix ownership after Docker operations
          echo "ğŸ”§ Fixing ownership after Docker operations..."
          sudo chown -R ${{ env.USER_ID }}:${{ env.GROUP_ID }} ${{ github.workspace }} || true
          sudo chmod -R 755 ${{ github.workspace }} || true

          # Post-deployment health check
          echo "ğŸ¥ Post-deployment health check..."
          sleep 30
          
          # Check all services are running
          if ! docker compose -f docker compose.production.yml ps | grep -q "Up"; then
            echo "âŒ Some services are not running after deployment"
            echo "ğŸ”„ Rolling back to previous version..."
            cp "$backup_path/docker compose.production.yml" ./ || true
            cp "$backup_path/.env" ./ || true
            cp "$backup_path/nginx.conf" ./.docker/production/nginx/ || true
            docker compose -f docker compose.production.yml up -d
            exit 1
          fi

          # Test API endpoint
          if curl -f -s http://localhost/api/health > /dev/null; then
            echo "âœ… API health check passed"
          else
            echo "âš ï¸ API health check failed, but deployment may still be successful"
          fi

          # Test frontend
          if curl -f -s http://localhost > /dev/null; then
            echo "âœ… Frontend is accessible"
          else
            echo "âš ï¸ Frontend test failed, but deployment may still be successful"
          fi

          # Cleanup old images
          echo "ğŸ§¹ Cleaning up old images..."
          docker image prune -f || true

          echo "âœ… Zero Downtime Deployment completed successfully!"
          echo "ğŸŒ Frontend: https://roommate.id.vn"
          echo "ğŸŒ Backend API: https://roommate.id.vn/api"
          echo "ğŸ¥ Health Check: https://roommate.id.vn/health"
          echo "ğŸ“Š Final services status:"
          docker compose -f docker compose.production.yml ps
