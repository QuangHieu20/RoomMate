name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # ==================== BUILD & TEST ====================
  build:
    name: Build & Test
    runs-on: self-hosted

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Create Environment File
        run: |
          echo "ğŸ” Creating environment file from GitHub Secrets..."
          
          # Create .env file using GitHub Secrets
          cat > .env << EOF
          # Database Configuration from GitHub Secrets
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

          # Backend Configuration
          NODE_ENV=production
          PORT=3000
          DATABASE_HOST=postgres
          DATABASE_PORT=5432
          DATABASE_NAME=${{ secrets.POSTGRES_DB }}
          DATABASE_USER=${{ secrets.POSTGRES_USER }}
          DATABASE_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          API_BASE_URL=${{ secrets.API_BASE_URL }}
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
          API_PORT=3000
          API_HOST=0.0.0.0

          # Frontend Configuration
          NUXT_PUBLIC_API_BASE=${{ secrets.NUXT_PUBLIC_API_BASE }}
          NUXT_PUBLIC_FRONTEND_URL=${{ secrets.NUXT_PUBLIC_FRONTEND_URL }}
          NUXT_PUBLIC_APP_NAME=${{ secrets.NUXT_PUBLIC_APP_NAME }}
          NUXT_PUBLIC_MEDIA_BASE=${{ secrets.NUXT_PUBLIC_MEDIA_BASE }}
          EOF

      - name: ğŸ“¦ Upload Environment File Artifact
        uses: actions/upload-artifact@v4
        with:
          name: env-file
          path: .env
          retention-days: 1

      - name: ğŸ§¹ Light Clean for Build Test
        run: |
          echo "ğŸ§¹ Light cleaning for build test (keeping containers)..."
          # Only clean unused images, keep containers running
          docker image prune -f || true

      - name: ğŸ—ï¸ Test Build Services
        run: |
          docker compose -f docker-compose.production.yml build --no-cache backend frontend

      - name: ğŸ”§ Fix ownership after Docker builds
        run: |
          sudo chown -R ${{ env.USER_ID }}:${{ env.GROUP_ID }} ${{ github.workspace }} || true
          sudo chmod -R 755 ${{ github.workspace }} || true

      - name: âœ… Build Test Completed
        run: echo "Build test completed successfully!"

  # ==================== DEPLOY ====================
  deploy:
    name: Deploy to Production
    runs-on: self-hosted
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Download Environment File Artifact
        uses: actions/download-artifact@v4
        with:
          name: env-file
          path: .

      - name: ğŸ” Verify Environment File
        run: |
          echo "ğŸ” Verifying environment file..."
          if [ -f .env ]; then
            echo "âœ… Environment file downloaded successfully"
            echo "ğŸ“‹ Environment variables:"
            grep -E "^[A-Z]" .env | head -5
            echo "..."
          else
            echo "âŒ Environment file not found"
            exit 1
          fi

      - name: ğŸš€ Zero Downtime Deploy to Production
        run: |
          echo "ğŸ“¥ Code already checked out..."

          # Create backup directory
          echo "ğŸ’¾ Creating backup directory..."
          mkdir -p /home/hieunq/roommate_backups
          timestamp=$(date +'%Y%m%d_%H%M%S')
          backup_path="/home/hieunq/roommate_backups/backup_$timestamp"
          mkdir -p "$backup_path"

          # Backup current deployment
          echo "ğŸ’¾ Backing up current deployment..."
          cp docker-compose.production.yml "$backup_path/" || true
          cp .env "$backup_path/" || true
          cp ./.docker/production/nginx/nginx.conf "$backup_path/" || true
          docker compose -f docker-compose.production.yml images > "$backup_path/images.txt" || true

          # Pre-deployment health check
          echo "ğŸ¥ Pre-deployment health check..."
          if docker compose -f docker-compose.production.yml ps | grep -q "Up"; then
            echo "ğŸ“Š Current services status:"
            docker compose -f docker-compose.production.yml ps
          fi

          # Smart cleanup - only clean unused images, keep running containers
          echo "ğŸ§¹ Smart cleanup (keeping running containers)..."
          docker image prune -f || true
          
          # Only remove stopped containers, not running ones
          docker container prune -f || true
          
          # Build new images without cache (fresh build)
          echo "ğŸ”¨ Building new images without cache..."
          docker compose -f docker-compose.production.yml build --no-cache --parallel backend frontend

          # True Zero Downtime Rolling Update
          echo "ğŸ”„ Starting true zero downtime rolling update..."

          # Step 1: Update postgres (usually no changes, but ensure it's running)
          echo "ğŸ“Š Ensuring postgres is running..."
          docker compose -f docker-compose.production.yml up -d --no-deps postgres
          sleep 5

          # Step 2: Rolling update backend using scaling
          echo "ğŸ”§ Rolling update backend using scaling strategy..."
          
          # Scale backend to 2 containers (creates new container alongside old one)
          docker compose -f docker-compose.production.yml up -d --no-deps --scale backend=2 backend
          
          # Wait for new backend container to be healthy
          echo "ğŸ¥ Waiting for new backend container to be healthy..."
          backend_healthy=false
          for i in {1..30}; do
            # Check if we have 2 backend containers and at least one is healthy
            backend_count=$(docker compose -f docker-compose.production.yml ps backend --format "table {{.Name}}" | grep -c "backend" || echo "0")
            if [ "$backend_count" -ge 2 ]; then
              if docker compose -f docker-compose.production.yml ps backend | grep -q "healthy"; then
                echo "âœ… New backend container is healthy"
                backend_healthy=true
                break
              fi
            fi
            echo "Attempt $i/30: New backend container not ready yet..."
            sleep 10
          done
          
          if [ "$backend_healthy" = false ]; then
            echo "âŒ New backend container failed to become healthy"
            echo "ğŸ”„ Rolling back backend..."
            docker compose -f docker-compose.production.yml up -d --no-deps --scale backend=1 backend
            exit 1
          fi

          # Scale back to 1 backend (this will stop the old container)
          echo "ğŸ”„ Scaling back to 1 backend (stopping old container)..."
          docker compose -f docker-compose.production.yml up -d --no-deps --scale backend=1 backend
          sleep 5
          
          # Clean up old backend containers to avoid port conflicts
          echo "ğŸ§¹ Cleaning up old backend containers..."
          docker compose -f docker-compose.production.yml rm -f backend || true
          sleep 2

          # Step 3: Rolling update frontend using scaling
          echo "ğŸ¨ Rolling update frontend using scaling strategy..."
          
          # Scale frontend to 2 containers (creates new container alongside old one)
          docker compose -f docker-compose.production.yml up -d --no-deps --scale frontend=2 frontend
          
          # Wait for new frontend container to be healthy
          echo "ğŸ¥ Waiting for new frontend container to be healthy..."
          frontend_healthy=false
          for i in {1..20}; do
            # Check if we have 2 frontend containers and at least one is healthy
            frontend_count=$(docker compose -f docker-compose.production.yml ps frontend --format "table {{.Name}}" | grep -c "frontend" || echo "0")
            if [ "$frontend_count" -ge 2 ]; then
              if docker compose -f docker-compose.production.yml ps frontend | grep -q "healthy"; then
                echo "âœ… New frontend container is healthy"
                frontend_healthy=true
                break
              fi
            fi
            echo "Attempt $i/20: New frontend container not ready yet..."
            sleep 5
          done
          
          if [ "$frontend_healthy" = false ]; then
            echo "âŒ New frontend container failed to become healthy"
            echo "ğŸ”„ Rolling back frontend..."
            docker compose -f docker-compose.production.yml up -d --no-deps --scale frontend=1 frontend
            exit 1
          fi

          # Scale back to 1 frontend (this will stop the old container)
          echo "ğŸ”„ Scaling back to 1 frontend (stopping old container)..."
          docker compose -f docker-compose.production.yml up -d --no-deps --scale frontend=1 frontend
          sleep 5
          
          # Clean up old frontend containers to avoid port conflicts
          echo "ğŸ§¹ Cleaning up old frontend containers..."
          docker compose -f docker-compose.production.yml rm -f frontend || true
          sleep 2

          # Step 4: Update nginx and reload configuration
          echo "ğŸŒ Updating nginx and reloading configuration..."
          docker compose -f docker-compose.production.yml up -d --no-deps nginx
          
          # Reload nginx configuration inside container
          echo "ğŸ”„ Reloading nginx configuration..."
          docker exec roommate_nginx_prod nginx -s reload || true
          sleep 5

          # Fix ownership after Docker operations
          echo "ğŸ”§ Fixing ownership after Docker operations..."
          sudo chown -R ${{ env.USER_ID }}:${{ env.GROUP_ID }} ${{ github.workspace }} || true
          sudo chmod -R 755 ${{ github.workspace }} || true

          # Post-deployment health check
          echo "ğŸ¥ Post-deployment health check..."
          sleep 30
          
          # Check all services are running
          if ! docker compose -f docker-compose.production.yml ps | grep -q "Up"; then
            echo "âŒ Some services are not running after deployment"
            echo "ğŸ”„ Rolling back to previous version..."
            cp "$backup_path/docker-compose.production.yml" ./ || true
            cp "$backup_path/.env" ./ || true
            cp "$backup_path/nginx.conf" ./.docker/production/nginx/ || true
            docker compose -f docker-compose.production.yml up -d
            exit 1
          fi

          # Test API endpoints through nginx load balancer
          echo "ğŸ¥ Testing API endpoints..."
          api_healthy=true
          
          # Test through nginx load balancer
          if curl -f -s http://localhost/api/health > /dev/null; then
            echo "âœ… API through nginx load balancer passed"
          else
            echo "âš ï¸ API through nginx load balancer failed"
            api_healthy=false
          fi

          # Test frontend through nginx load balancer
          echo "ğŸ¥ Testing frontend..."
          frontend_healthy=true
          
          # Test through nginx load balancer
          if curl -f -s http://localhost > /dev/null; then
            echo "âœ… Frontend through nginx load balancer passed"
          else
            echo "âš ï¸ Frontend through nginx load balancer failed"
            frontend_healthy=false
          fi
          
          # Overall health check
          if [ "$api_healthy" = true ] && [ "$frontend_healthy" = true ]; then
            echo "âœ… All health checks passed"
          else
            echo "âš ï¸ Some health checks failed, but deployment may still be successful"
          fi

          # Cleanup old images
          echo "ğŸ§¹ Cleaning up old images..."
          docker image prune -f || true
          
          # Final cleanup - remove any stopped containers to avoid conflicts
          echo "ğŸ§¹ Final cleanup - removing stopped containers..."
          docker container prune -f || true

          echo "âœ… Zero Downtime Deployment completed successfully!"
          echo "ğŸŒ Frontend: https://roommate.id.vn"
          echo "ğŸŒ Backend API: https://roommate.id.vn/api"
          echo "ğŸ¥ Health Check: https://roommate.id.vn/health"
          echo ""
          echo "ğŸ“Š Load Balancer Status:"
          echo "Backend: http://localhost/api/health (load balanced)"
          echo "Frontend: http://localhost (load balanced)"
          echo ""
          echo "ğŸ“Š Final services status:"
          docker compose -f docker-compose.production.yml ps
