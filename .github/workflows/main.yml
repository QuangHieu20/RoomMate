name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  # ==================== BUILD & TEST ====================
  build:
    name: Build & Test
    runs-on: self-hosted

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Setup Environment Variables for Build Test
        run: |
          echo "ğŸ” Setting up environment variables for build test..."
          
          # Create .env file using GitHub Secrets
          cat > .env << EOF
          # Database Configuration from GitHub Secrets
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

          # Backend Configuration
          NODE_ENV=production
          PORT=3000
          DATABASE_HOST=postgres
          DATABASE_PORT=5432
          DATABASE_NAME=${{ secrets.POSTGRES_DB }}
          DATABASE_USER=${{ secrets.POSTGRES_USER }}
          DATABASE_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          API_BASE_URL=${{ secrets.API_BASE_URL }}
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
          API_PORT=3000
          API_HOST=0.0.0.0

          # Frontend Configuration
          NUXT_PUBLIC_API_BASE=${{ secrets.NUXT_PUBLIC_API_BASE }}
          NUXT_PUBLIC_FRONTEND_URL=${{ secrets.NUXT_PUBLIC_FRONTEND_URL }}
          NUXT_PUBLIC_APP_NAME=${{ secrets.NUXT_PUBLIC_APP_NAME }}
          NUXT_PUBLIC_MEDIA_BASE=${{ secrets.NUXT_PUBLIC_MEDIA_BASE }}
          EOF

      - name: ğŸ§¹ Light Clean for Build Test
        run: |
          echo "ğŸ§¹ Light cleaning for build test (keeping containers)..."
          # Only clean unused images, keep containers running
          docker image prune -f || true

      - name: ğŸ—ï¸ Test Build Backend
        run: |
          docker compose -f docker-compose.production.yml build --no-cache backend

      - name: ğŸ—ï¸ Test Build Frontend
        run: |
          docker compose -f docker-compose.production.yml build --no-cache frontend

      - name: ğŸ”§ Fix ownership after Docker builds
        run: |
          sudo chown -R ${{ env.USER_ID }}:${{ env.GROUP_ID }} ${{ github.workspace }} || true
          sudo chmod -R 755 ${{ github.workspace }} || true

      - name: âœ… Build Test Completed
        run: echo "Build test completed successfully!"

  # ==================== DEPLOY ====================
  deploy:
    name: Deploy to Production
    runs-on: self-hosted
    needs: build
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Setup Environment Variables from GitHub Secrets
        run: |
          echo "ğŸ” Setting up environment variables from GitHub secrets..."

          # Create .env file from GitHub secrets
          cat > .env << EOF
          # Database Configuration from GitHub Secrets
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}

          # Backend Configuration
          NODE_ENV=production
          PORT=3000
          DATABASE_HOST=postgres
          DATABASE_PORT=5432
          DATABASE_NAME=${{ secrets.POSTGRES_DB }}
          DATABASE_USER=${{ secrets.POSTGRES_USER }}
          DATABASE_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          API_BASE_URL=${{ secrets.API_BASE_URL }}
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
          API_PORT=${{ secrets.API_PORT }}
          API_HOST=${{ secrets.API_HOST }}

          # Frontend Configuration
          NUXT_PUBLIC_API_BASE=${{ secrets.NUXT_PUBLIC_API_BASE }}
          NUXT_PUBLIC_FRONTEND_URL=${{ secrets.NUXT_PUBLIC_FRONTEND_URL }}
          NUXT_PUBLIC_APP_NAME=${{ secrets.NUXT_PUBLIC_APP_NAME }}
          NUXT_PUBLIC_MEDIA_BASE=${{ secrets.NUXT_PUBLIC_MEDIA_BASE }}
          EOF

      - name: ğŸš€ Zero Downtime Deploy to Production
        run: |
          echo "ğŸ“¥ Code already checked out..."

          # Create backup directory
          echo "ğŸ’¾ Creating backup directory..."
          mkdir -p /home/hieunq/roommate_backups
          timestamp=$(date +'%Y%m%d_%H%M%S')
          backup_path="/home/hieunq/roommate_backups/backup_$timestamp"
          mkdir -p "$backup_path"

          # Backup current deployment
          echo "ğŸ’¾ Backing up current deployment..."
          cp docker-compose.production.yml "$backup_path/" || true
          cp .env "$backup_path/" || true
          cp ./.docker/production/nginx/nginx.conf "$backup_path/" || true
          docker compose -f docker-compose.production.yml images > "$backup_path/images.txt" || true

          # Pre-deployment health check
          echo "ğŸ¥ Pre-deployment health check..."
          if docker compose -f docker-compose.production.yml ps | grep -q "Up"; then
            echo "ğŸ“Š Current services status:"
            docker compose -f docker-compose.production.yml ps
          fi

          # Smart cleanup - only clean unused images, keep running containers
          echo "ğŸ§¹ Smart cleanup (keeping running containers)..."
          docker image prune -f || true
          
          # Only remove stopped containers, not running ones
          docker container prune -f || true
          
          # Build new images without cache (fresh build)
          echo "ğŸ”¨ Building new images without cache..."
          docker compose -f docker-compose.production.yml build --no-cache --parallel

          # True Zero Downtime Rolling Update
          echo "ğŸ”„ Starting true zero downtime rolling update..."

          # Step 1: Update postgres (usually no changes, but ensure it's running)
          echo "ğŸ“Š Ensuring postgres is running..."
          docker compose -f docker-compose.production.yml up -d --no-deps postgres
          sleep 5

          # Step 2: Rolling update backend with proper strategy
          echo "ğŸ”§ Rolling update backend..."
          
          # Create new backend container with different name
          docker compose -f docker-compose.production.yml up -d --no-deps --scale backend=2 backend
          
          # Wait for new backend to be healthy
          echo "ğŸ¥ Waiting for new backend to be healthy..."
          backend_healthy=false
          for i in {1..30}; do
            # Check if we have 2 backend containers and at least one is healthy
            backend_count=$(docker compose -f docker-compose.production.yml ps backend --format "table {{.Name}}" | grep -c "backend" || echo "0")
            if [ "$backend_count" -ge 2 ]; then
              if docker compose -f docker-compose.production.yml ps backend | grep -q "healthy"; then
                echo "âœ… New backend is healthy"
                backend_healthy=true
                break
              fi
            fi
            echo "Attempt $i/30: New backend not ready yet..."
            sleep 10
          done
          
          if [ "$backend_healthy" = false ]; then
            echo "âŒ New backend failed to become healthy"
            echo "ğŸ”„ Rolling back backend..."
            docker compose -f docker-compose.production.yml up -d --no-deps --scale backend=1 backend
            exit 1
          fi

          # Scale back to 1 backend (this will stop the old one)
          echo "ğŸ”„ Scaling back to 1 backend (stopping old container)..."
          docker compose -f docker-compose.production.yml up -d --no-deps --scale backend=1 backend
          sleep 5

          # Step 3: Rolling update frontend with proper strategy
          echo "ğŸ¨ Rolling update frontend..."
          
          # Create new frontend container with different name
          docker compose -f docker-compose.production.yml up -d --no-deps --scale frontend=2 frontend
          
          # Wait for new frontend to be healthy
          echo "ğŸ¥ Waiting for new frontend to be healthy..."
          frontend_healthy=false
          for i in {1..20}; do
            # Check if we have 2 frontend containers and at least one is healthy
            frontend_count=$(docker compose -f docker-compose.production.yml ps frontend --format "table {{.Name}}" | grep -c "frontend" || echo "0")
            if [ "$frontend_count" -ge 2 ]; then
              if docker compose -f docker-compose.production.yml ps frontend | grep -q "healthy"; then
                echo "âœ… New frontend is healthy"
                frontend_healthy=true
                break
              fi
            fi
            echo "Attempt $i/20: New frontend not ready yet..."
            sleep 5
          done
          
          if [ "$frontend_healthy" = false ]; then
            echo "âŒ New frontend failed to become healthy"
            echo "ğŸ”„ Rolling back frontend..."
            docker compose -f docker-compose.production.yml up -d --no-deps --scale frontend=1 frontend
            exit 1
          fi

          # Scale back to 1 frontend (this will stop the old one)
          echo "ğŸ”„ Scaling back to 1 frontend (stopping old container)..."
          docker compose -f docker-compose.production.yml up -d --no-deps --scale frontend=1 frontend
          sleep 5

          # Step 4: Update nginx (usually no changes, but ensure it's running)
          echo "ğŸŒ Ensuring nginx is running..."
          docker compose -f docker-compose.production.yml up -d --no-deps nginx
          sleep 5

          # Fix ownership after Docker operations
          echo "ğŸ”§ Fixing ownership after Docker operations..."
          sudo chown -R ${{ env.USER_ID }}:${{ env.GROUP_ID }} ${{ github.workspace }} || true
          sudo chmod -R 755 ${{ github.workspace }} || true

          # Post-deployment health check
          echo "ğŸ¥ Post-deployment health check..."
          sleep 30
          
          # Check all services are running
          if ! docker compose -f docker-compose.production.yml ps | grep -q "Up"; then
            echo "âŒ Some services are not running after deployment"
            echo "ğŸ”„ Rolling back to previous version..."
            cp "$backup_path/docker-compose.production.yml" ./ || true
            cp "$backup_path/.env" ./ || true
            cp "$backup_path/nginx.conf" ./.docker/production/nginx/ || true
            docker compose -f docker-compose.production.yml up -d
            exit 1
          fi

          # Test API endpoint
          if curl -f -s http://localhost/api/health > /dev/null; then
            echo "âœ… API health check passed"
          else
            echo "âš ï¸ API health check failed, but deployment may still be successful"
          fi

          # Test frontend
          if curl -f -s http://localhost > /dev/null; then
            echo "âœ… Frontend is accessible"
          else
            echo "âš ï¸ Frontend test failed, but deployment may still be successful"
          fi

          # Cleanup old images
          echo "ğŸ§¹ Cleaning up old images..."
          docker image prune -f || true

          echo "âœ… Zero Downtime Deployment completed successfully!"
          echo "ğŸŒ Frontend: https://roommate.id.vn"
          echo "ğŸŒ Backend API: https://roommate.id.vn/api"
          echo "ğŸ¥ Health Check: https://roommate.id.vn/health"
          echo "ğŸ“Š Final services status:"
          docker compose -f docker-compose.production.yml ps
